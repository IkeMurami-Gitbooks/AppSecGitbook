# Host Header Injection

![](<../../.gitbook/assets/изображение (5).png>)

```
Host: example1.com
 Host: example2.com
X-Originating-IP: 127.0.1.1
X-Forwarded-For: example3.com
X-Remote-IP: 127.0.2.1
X-Remote-Addr: 127.0.3.1
X-Client-IP: 127.0.4.1
X-Forwarded-Host: example4.com
X-Host: example5.com
X-Forwarded-Server: example6.com
X-HTTP-Host-Override: example7.com
Forwarded: host=example8.com
X-Forwarded-Proto: http
X-Forwarded-Scheme: http
X-HTTP-Method-Override: POST
X-Original-URL: /admin1
Pragma: x-get-cache-key
...

TODO:
Вообщее лучше иметь хендлер, конечно, который по поддомену подсветит, откуда запрос
Пройтись по ParamMiner нагрузкам
Добавление символов пробельных и других
Request Headers Pollution
```

## About

Когда возможно, что несколько приложений на одном хосте

* Virtual Hosts (Например, несколько вебчиков на одном хост, SaaS)
* Маршрутизация трафика через один хост к приложениям во внутрь сети (это мб балансировщик нагрузки, реверс прокси-сервер, content delivery nework (CDN))

В обоих этих сценариях заголовок Host используется для указания предполагаемого получателя. Обычно, веб приложения не знают на каком домене развернуты и вынуждены обращаться к Host заголовку.

Даже если сам заголовок Host обрабатывается более безопасно, в зависимости от конфигурации серверов, которые обрабатывают входящие запросы, Host потенциально может быть переопределен путем внедрения других заголовков. Иногда владельцы веб-сайтов не знают, что эти заголовки поддерживаются по умолчанию, и, как следствие, к ним могут не относиться с такой же тщательностью.

Фактически, многие из этих уязвимостей возникают не из-за небезопасного кодирования, а из-за небезопасной конфигурации одного или нескольких компонентов в соответствующей инфраструктуре. Эти проблемы с конфигурацией могут возникать из-за того, что веб-сайты интегрируют сторонние технологии в свою архитектуру без необходимости понимания параметров конфигурации и их последствий для безопасности.

## Exploiting

Коротко,чтобы проверить, может ли быть уязвим к подобной атаке:

* Сделать запрос к хосту с подменненным host заголовком
* Если вы можете по прежнему обращаться к веб-приложению — продолжаем тестирование, можем менять заголовок, в принципе

### Отправляем всякую херь

Первое что пробуем: отпровить херню какую-то. Могут быть разные результаты. Если у сервера указано, куда перенаправлять код по умолчанию — нам повезло. Иногда такого не происходит, можно попробовать что-нибудь из того, что описано далее

Иногда, вместо ошибки "Недопустимый заголовок хоста", мы будем получать, что хост заблокировал нас из-за каких-то вопросов безопасности (например, что host не совпадает с тем, что указано в TLS при рукупожатии (SNI)). Это не означает, что приложение не подввержено этой уязвимости.

Важно суметь понять, что приложение обрабатывает заголовок Host. Для этого можно попробовать вставлять что угодно как хост, порт (не обяз числовое значени) и тд. Некоторые сайты магическим образом себя ведут, если, например, host заканчивается на валидный домен.

```
GET /example HTTP/1.1
Host: vulnerable-website.com:bad-stuff-here

GET /example HTTP/1.1
Host: notvulnerable-website.com 

GET /example HTTP/1.1
Host: hacked-subdomain.vulnerable-website.com 
```

### Делать необычные запросы

Некоторые примеры:

#### Host Header Pollution

```
GET /example HTTP/1.1
Host: vulnerable-website.com
Host: bad-stuff-here 
```

#### Использовать абсолютные пути URL

```
GET https://vulnerable-website.com/ HTTP/1.1
Host: bad-stuff-here 
```

#### Добавление пробелов или других символов

```
GET /example HTTP/1.1
 Host: bad-stuff-here
Host: vulnerable-website.com 
```

#### HTTP Request Smuggling

### Внедрение заголовков, переопределяющих заголовок Host

Например, некоторые фреймворки будут обрабатывать X-Forwarded-Host (это может помочь обойти все защиты на основной заголовок)

```
GET /example HTTP/1.1
Host: vulnerable-website.com
X-Forwarded-Host: bad-stuff-here
```

Другие заголовки, служащие похожей цели:

* &#x20;`X-Host`
* &#x20;`X-Forwarded-Server`
* &#x20;`X-HTTP-Host-Override`
* &#x20;`Forwarded: host=myevilhost`

В Burp Suite есть плагин, который перебирает всякие параметры, в том числе и заголовки — Param Miner.

### Web Cache Poisoning

Можем влиять на веб кеш таким образом

### Эксплуатация классических вулнов, типа SQLi

### Обход аутентификации&#x20;

### Доступ ко внутренним ресурсам / SSRF

Путем брута виртуальных хостов, обращение ко внутренним ресурсам компании

SSRF via a malfomed request line

```
GET /example HTTP/1.1
Host: example.com

--> example.com/example

но

GET @intranet-backend/example HTTP/1.1
Host: example.com

--> example.com@intranet-backend/example
```

### Password reset poisoning

Суть атаки, что на запросе восстановления пароля мы поддменяем на свой host header. Если приложения уязвимо, то оно отправит пользователю ссылку на восстановление пароля с нашим доменом, указанном в host заголовке. После этого, мы сможем перехватить токен восстановления пароля и получить доступ к аккаунту жертвы.

![](<../../.gitbook/assets/изображение (16).png>)

## Preventing

* Protect absolute URLs
* Validate the Host Header
* Не поддерживать заголовки, переопределяющие Host, в частности X-Forwarded-Host (главное помнить, что они могут поддерживаться по умолчанию)
* Использовать белые списки для разрешенных доменов

