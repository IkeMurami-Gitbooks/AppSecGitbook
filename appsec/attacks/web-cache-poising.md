# Web Cache Poising

## About

Механизм Web Cache появился для того, чтобы снизить нагрузку на сервера (чтобы н еотвечать на каждый запрос клиентов).

Для работы этого механизма сервер определяет ключи для кэширования (параметры, по которым определяются идентичные запросы).

Нюанс: Если тестеры на проникновение или автоматические сканеры получают только кешированные ответы, не осознавая этого, может показаться, что на странице нет каких-то уязвимостей (например, rXSS).

## Что нужно для того, чтобы провести атаку травления кэша

1. Определить и вычислить некэшируемые ключи
2. Вызвать вредоносный ответ от бэкенд сервера
3. Получить закэшированный ответ

### Некэшируемые ключи

Что это может быть:

* Заголовки
* Пути
* Куки
* Параметры

Травить кэш через заголовки — не единствнный, но самый действенный. Другие способы — _HTTP Response Spliting_ и _Request Smuggling_.&#x20;

Меняем ключи в запросах — сравниваем ответы (например, через Burp Comparer). Автоматизированно это можно сделать через _Param Miner_, выбираем Guess Headers.&#x20;

**Нюанс**: если не использовать при бруте уникальные ключи, то мы рискуем отравить кэш реальных пользователей.  Чтобы этого избежать, можно использовать уникальные ключи или проставлять специальный параметр в запрос (какой?). В Param Miner это можно указать.

**Нюанс**: кэшироваться могут все параметры и заголовки. Если payload становиться частью кэшируемых параметров, то потенциальная цель никогда не попадет на ваш payload. Однако при ближайшем рассмотрении поведение отдельных систем кэширования не всегда такое, как можно было бы ожидать. На практике многие веб-сайты и CDN выполняют различные преобразования ключевых компонентов, когда они сохраняются в ключе кеша. Это может включать:

* &#x20;Excluding the query string
* &#x20;Filtering out specific query parameters
* &#x20;Normalizing input in keyed components

### Web Cache Oracle

Под оракулом понимается веб-страница, предоставляющая обратную связь о поведении кэша — информацию о том, получаем мы ответ с сервера или с кэшированный ответ.&#x20;

Эта обратная связь может принимать различные формы, например:

* Заголовок HTTP, который явно сообщает вам, есть ли у вас попадание в кеш
* Наблюдаемые изменения динамического контента
* Четкое время отклика

Если вы можете определить, что используется определенный сторонний кеш, вы также можете обратиться к соответствующей документации. Это может содержать информацию о том, как создается ключ кеша по умолчанию. Вы можете даже наткнуться на некоторые полезные советы и рекомендации, например, функции, позволяющие напрямую видеть ключ кеша. Например, веб-сайты на основе Akamai могут поддерживать заголовок `Pragma: akamai-x-get-cache-key`, который вы можете использовать для отображения ключа кеша в заголовках ответов:

`GET /?param=1 HTTP/1.1`\
`Host: innocent-website.com`\
`Pragma: akamai-x-get-cache-key`\
``\
`HTTP/1.1 200 OK`\
`X-Cache-Key: innocent-website.com/?param=1`

#### cache-buster

Гарантия того что файл будет загружен с сервера, а не взят из кеша браузера. Разумеется, если "добавка" будет меняться при изменении содержимого файла. Суть в добавлении различных символов к файлам и параметрам:

```javascript
было
<script src="/scripts.js"></script>

+ cache-buster — стало:

<script src="/scripts.js?0fe798ab-e95d-47b6-a281-325a7345f913"></script>
```

Альтернативные способы:

```
Accept-Encoding: gzip, deflate, cachebuster
Accept: */*, text/cachebuster
Cookie: cachebuster=1
Origin: https://cachebuster.vulnerable-website.com 
```

Так же, техника cache-buster защищает от того, что будет отравлен кэш случайного пользователя. Рекомендуется использовать эту технику при тестировании.

В Burp как уникальное значение для cash-buster можно использовать timestamp из hackvertor

#### Разница в нормализации path в запросе

Поскольку путь почти гарантированно будет иметь ключ, вы можете иногда использовать это для отправки запросов с разными ключами, которые по-прежнему попадают в одну и ту же конечную точку. Например, следующие записи могут все кэшироваться отдельно, но обрабатываться как эквивалент GET / на сервере:

```
Apache: GET //
Nginx: GET /%2F
PHP: GET /index.php/xyz
.NET GET /(A(xyz)/
```

#### Разница в обработке параметров

Кэш-сервер и бэкенд-сервер могут по-разному парсить входные параметры. Например:

```
GET /?test=1?test2=1&test3=1
Может быть обработан различно в зависимости от того, как будут парситься знак ?

Ruby
Для Ruby ; как и & — одинаковые разделители:
GET /?test1=1&test2=1;test2=2
Ruby распарсит как три параметра, а кэш сервер как два

Еще особенность Ruby — при parameters pollution фреймворк выберет последнее значение.
```

### Определить возможный импакт

Надо понять, что можно сделать через эти некэшируемые ключи

Манипулирование входными данными для получения вредоносного ответа - полдела, но это не дает многого, если вы не можете кэшировать ответ, что иногда может быть сложно.

Будет ли кеширован ответ или нет, может зависеть от таких факторов, как расширение файла, тип содержимого, маршрут, код состояния и заголовки ответа. Возможно, вам нужно будет потратить некоторое время на то, чтобы просто поиграть с запросами на разных страницах и изучить, как ведет себя кеш. Как только вы определитесь, как получить кэшированный ответ, содержащий ваши вредоносные данные, вы готовы передать эксплойт потенциальным жертвам.

## How to prevent web cache poisoning vulnerabilities

Верный способ предотвратить заражение веб-кеша - это полностью отключить кеширование. Хотя для многих веб-сайтов это может быть нереалистичным вариантом, в других случаях это может быть осуществимо. Например, если вы используете кеширование только потому, что оно было включено по умолчанию при внедрении CDN, возможно, стоит оценить: действительно ли,  включенные параметры кэширования по умолчанию, отражают ваши потребности.

## Papers

Статья 1: [https://portswigger.net/research/practical-web-cache-poisoning](https://portswigger.net/research/practical-web-cache-poisoning)\
Статья 2 (продолжение предыдущей): [https://portswigger.net/research/web-cache-entanglement](https://portswigger.net/research/web-cache-entanglement)\
Статья 3 (Bo0om): [https://bo0om.ru/web-cache-deception-attack](https://bo0om.ru/web-cache-deception-attack)\
Статья 4: [https://snyk.io/blog/cache-poisoning-in-popular-open-source-packages/](https://snyk.io/blog/cache-poisoning-in-popular-open-source-packages/)

&#x20;
